name: üöÄ D√©ploiement (g√©n√©rique)

on:
  workflow_call:
    secrets:
      SFTP_HOST:
        required: true
        description: "H√¥te SFTP du serveur distant"
      SFTP_USER:
        required: true
        description: "Utilisateur SFTP pour la connexion"
      SSH_PRIVATE_KEY:
        required: true
        description: "Cl√© priv√©e SSH pour l'authentification"
      REMOTE_CHEMIN:
        required: true
        description: "Chemin de base sur le serveur distant"
    inputs:
      SFTP_PORT:
        required: false
        type: string
        default: "22"
        description: "Port SFTP (g√©n√©ralement 22)"
      ADRESSE_GLOBAL:
        required: true
        type: string
        description: "Var repo: pr√©fixe global (ex: /var/www)"
      ADRESSE_LOCAL:
        required: true
        type: string
        description: "Var repo: sous-dossier projet/app"
      remote_env:
        required: true
        type: string
        description: "ENV: dev | homol | prod"
      PATH_ORDER:
        required: false
        type: string
        default: "env-local"
        description: "Ordre des segments finaux: 'local-env' ou 'env-local'"
      enable_mirror:
        required: false
        type: boolean
        default: false
        description: "Active le miroir de branche (homol->main ou develop->homol)"
      mirror_source:
        required: false
        type: string
        description: "Branche source du miroir (develop ou homol)"
      mirror_target:
        required: false
        type: string
        description: "Branche cible du miroir (homol ou main)"

permissions:
  contents: read

jobs:
  mirror-branch:
    name: üîÅ Miroir de branche
    if: ${{ inputs.enable_mirror == true }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Validate inputs
        shell: bash
        run: |
          : "Validate repo vars via inputs"
          test -n "${{ inputs.ADRESSE_GLOBAL }}" || { echo "::error::ADRESSE_GLOBAL manquant (var repo)"; exit 1; }
          test -n "${{ inputs.ADRESSE_LOCAL }}"  || { echo "::error::ADRESSE_LOCAL manquant (var repo)"; exit 1; }
          case "${{ inputs.remote_env }}" in dev|homol|prod) ;; *) echo "::error::remote_env invalide (dev|homol|prod)"; exit 1;; esac
          case "${{ inputs.PATH_ORDER }}" in local-env|env-local) ;; *) echo "::error::PATH_ORDER invalide (local-env|env-local)"; exit 1;; esac
          test -n "${{ inputs.mirror_source }}" || { echo "::error::mirror_source manquant"; exit 1; }
          test -n "${{ inputs.mirror_target }}" || { echo "::error::mirror_target manquant"; exit 1; }

      - name: ü§ñ R√©cup√©rer le d√©p√¥t (historique complet)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cr√©er une PR de miroir ${{ inputs.mirror_source }} ‚Üí ${{ inputs.mirror_target }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const sourceBranch = '${{ inputs.mirror_source }}';
            const targetBranch = '${{ inputs.mirror_target }}';

            try {
              // Cr√©er une branche temporaire depuis la source
              const tempBranch = `mirror/${targetBranch}-${Date.now()}`;

              // R√©cup√©rer le SHA de la branche source
              const sourceRef = await github.rest.git.getRef({
                owner,
                repo,
                ref: `heads/${sourceBranch}`
              });

              core.info(`SHA de ${sourceBranch}: ${sourceRef.data.object.sha}`);

              // Cr√©er la branche temporaire
              await github.rest.git.createRef({
                owner,
                repo,
                ref: `refs/heads/${tempBranch}`,
                sha: sourceRef.data.object.sha
              });

              core.info(`‚úÖ Branche temporaire cr√©√©e: ${tempBranch}`);

              // V√©rifier si une PR existe d√©j√†
              const existingPRs = await github.rest.pulls.list({
                owner,
                repo,
                head: `${owner}:${tempBranch}`,
                base: targetBranch,
                state: 'open'
              });

              let prNumber;

              if (existingPRs.data.length > 0) {
                prNumber = existingPRs.data[0].number;
                core.info(`PR existante trouv√©e: #${prNumber}`);
              } else {
                // Cr√©er une PR pour fusionner tempBranch dans targetBranch
                const pr = await github.rest.pulls.create({
                  owner,
                  repo,
                  title: `üîÅ [AUTO] Miroir ${sourceBranch} ‚Üí ${targetBranch}`,
                  body: `Fusion automatique pour synchroniser \`${targetBranch}\` avec \`${sourceBranch}\`\n\nCette PR a √©t√© cr√©√©e automatiquement par le workflow de d√©ploiement.`,
                  head: tempBranch,
                  base: targetBranch
                });

                prNumber = pr.data.number;
                core.info(`‚úÖ PR cr√©√©e: #${prNumber}`);
              }

              // Fusionner la PR avec squash pour √©viter les commits de merge
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: `üîÅ Miroir ${sourceBranch} ‚Üí ${targetBranch}`,
                commit_message: `Synchronisation automatique via workflow\n\nSource: ${sourceBranch}\nCible: ${targetBranch}`
              });

              core.info(`‚úÖ PR fusionn√©e avec squash`);

              // Supprimer la branche temporaire
              try {
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: `heads/${tempBranch}`
                });
                core.info(`‚úÖ Branche temporaire supprim√©e`);
              } catch (delError) {
                core.warning(`Impossible de supprimer la branche temporaire: ${delError.message}`);
              }

              core.info(`‚úÖ Miroir ${targetBranch} = ${sourceBranch} effectu√© via PR`);

            } catch (error) {
              core.setFailed(`Erreur lors du miroir: ${error.message}`);
              throw error;
            }

  deploy:
    name: üöÄ D√©ployer sur le serveur ${{ inputs.remote_env }}
    if: |
      always() &&
      github.event.pull_request.merged == true &&
      (needs.mirror-branch.result == 'success' || needs.mirror-branch.result == 'skipped')
    needs: mirror-branch
    runs-on: ubuntu-latest

    steps:
      - name: Validate inputs
        shell: bash
        run: |
          : "Validate repo vars via inputs"
          test -n "${{ inputs.ADRESSE_GLOBAL }}" || { echo "::error::ADRESSE_GLOBAL manquant (var repo)"; exit 1; }
          test -n "${{ inputs.ADRESSE_LOCAL }}"  || { echo "::error::ADRESSE_LOCAL manquant (var repo)"; exit 1; }
          case "${{ inputs.remote_env }}" in dev|homol|prod) ;; *) echo "::error::remote_env invalide (dev|homol|prod)"; exit 1;; esac
          case "${{ inputs.PATH_ORDER }}" in local-env|env-local) ;; *) echo "::error::PATH_ORDER invalide (local-env|env-local)"; exit 1;; esac

      - name: V√©rifier variables requises
        shell: bash
        env:
          REMOTE_CHEMIN: ${{ secrets.REMOTE_CHEMIN }}
          ADRESSE_GLOBAL: ${{ inputs.ADRESSE_GLOBAL }}
          ADRESSE_LOCAL: ${{ inputs.ADRESSE_LOCAL }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
          SFTP_USER: ${{ secrets.SFTP_USER }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          miss=0
          for v in REMOTE_CHEMIN ADRESSE_GLOBAL ADRESSE_LOCAL SFTP_HOST SFTP_USER SSH_PRIVATE_KEY; do
            if [ -z "${!v}" ]; then
              echo "::error title=Variable manquante::$v n'est pas d√©fini."
              miss=1
            else
              echo "::notice title=Variable::$v=${!v}"
            fi
          done
          [ "$miss" -eq 0 ] || exit 1

      - name: R√©cup√©rer le code
        uses: actions/checkout@v4

      - name: Construire le chemin distant normalis√© (sans cr√©ation)
        id: path
        shell: bash
        env:
          REMOTE_CHEMIN: ${{ secrets.REMOTE_CHEMIN }}
          ADRESSE_GLOBAL: ${{ inputs.ADRESSE_GLOBAL }}
          ADRESSE_LOCAL: ${{ inputs.ADRESSE_LOCAL }}
          REMOTE_ENV: ${{ inputs.remote_env }}
          PATH_ORDER: ${{ inputs.PATH_ORDER }}
        run: |
          norm() { printf "%s" "$1" | sed -e 's#//*#/#g' -e 's#^/##' -e 's#/$##'; }
          _remote="$(norm "$REMOTE_CHEMIN")"
          _env="$(norm "$REMOTE_ENV")"
          _glob="$(norm "$ADRESSE_GLOBAL")"
          _loca="$(norm "$ADRESSE_LOCAL")"

          # Chemin attendu (param√©trable) : REMOTE_CHEMIN/ADRESSE_GLOBAL/(ADRESSE_LOCAL/ENV | ENV/ADRESSE_LOCAL)
          if [ "$PATH_ORDER" = "env-local" ]; then
            _pair="${_env}/${_loca}"
          else
            _pair="${_loca}/${_env}"
          fi
          REMOTE_PATH="/${_remote}/${_glob}/${_pair}"
          REMOTE_PATH="$(echo "$REMOTE_PATH" | sed -e 's#//*#/#g')"

          echo "REMOTE_PATH=$REMOTE_PATH" >> "$GITHUB_OUTPUT"
          echo "::notice title=PATH_ORDER::$PATH_ORDER"
          echo "::notice title=REMOTE_PATH::$REMOTE_PATH"

      - name: Pr√©parer l'agent SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Ajouter h√¥te dans known_hosts
        shell: bash
        env:
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
          SFTP_PORT: ${{ inputs.SFTP_PORT }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "${SFTP_PORT:-22}" "$SFTP_HOST" >> ~/.ssh/known_hosts 2>/dev/null
          chmod 600 ~/.ssh/known_hosts

      - name: V√©rifier la connexion SSH
        shell: bash
        env:
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
          SFTP_USER: ${{ secrets.SFTP_USER }}
          SFTP_PORT: ${{ inputs.SFTP_PORT }}
        run: |
          ssh -o BatchMode=yes -o StrictHostKeyChecking=yes -p "${SFTP_PORT:-22}" "$SFTP_USER@$SFTP_HOST" "echo 'Connexion SSH OK'"

      - name: D√©ployer les fichiers (rsync avec .rsync-ignore si pr√©sent)
        shell: bash
        env:
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
          SFTP_USER: ${{ secrets.SFTP_USER }}
          SFTP_PORT: ${{ inputs.SFTP_PORT }}
        run: |
          REMOTE_PATH="${{ steps.path.outputs.REMOTE_PATH }}"
          echo "D√©ploiement vers : $REMOTE_PATH"

          # Fail si le dossier n'existe pas (on NE LE CREE PAS)
          ssh -p "${SFTP_PORT:-22}" "$SFTP_USER@$SFTP_HOST" "[ -d \"$REMOTE_PATH\" ]" \
            || { echo "::error title=Dossier distant manquant::Le dossier $REMOTE_PATH n'existe pas."; exit 1; }

          # Pr√©pare les exclusions (.rsync-ignore si pr√©sent)
          RSYNC_EXCLUDES=(--exclude='.git/' --exclude='.github/')
          if [ -f ".rsync-ignore" ]; then
            echo "::notice title=rsync::Utilisation de .rsync-ignore"
            RSYNC_EXCLUDES+=(--exclude-from='.rsync-ignore')
          else
            echo "::notice title=rsync::Aucun .rsync-ignore trouv√© √† la racine du d√©p√¥t"
          fi

          # Synchronisation (idempotente) + suppression des fichiers retir√©s c√¥t√© source
          rsync -az --delete \
            "${RSYNC_EXCLUDES[@]}" \
            -e "ssh -p ${SFTP_PORT:-22}" \
            ./ "$SFTP_USER@$SFTP_HOST:$REMOTE_PATH/"

          echo "‚úÖ D√©ploiement termin√©."
